"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.profanity = exports.Profanity = void 0;
const path_1 = require("path");
const profanity_options_1 = require("./profanity-options");
const list_1 = require("./list");
function escapeRegExp(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
class Profanity {
    constructor(options) {
        this.options = options || new profanity_options_1.ProfanityOptions();
        this.whitelist = new list_1.List(() => this.buildRegex());
        this.blacklist = new list_1.List(() => this.buildRegex());
        this.blacklist.loadFile(path_1.resolve(__dirname, "words.txt"));
    }
    exists(text) {
        this.regex.lastIndex = 0;
        return this.regex.test(text);
    }
    censor(text) {
        return text.replace(this.regex, this.options.grawlix);
    }
    addWords(words) {
        this.blacklist.addWords(words);
    }
    removeWords(words) {
        this.blacklist.removeWords(words);
    }
    buildRegex() {
        const escapedBlacklistWords = this.blacklist.words.map(escapeRegExp);
        const escapedWhitelistWords = this.whitelist.words.map(escapeRegExp);
        const blacklistPattern = `${this.options.wholeWord ? "\\b" : ""}(${escapedBlacklistWords.join("|")})${this.options.wholeWord ? "\\b" : ""}`;
        const whitelistPattern = this.whitelist.empty ? "" : `(?!${escapedWhitelistWords.join("|")})`;
        this.regex = new RegExp(whitelistPattern + blacklistPattern, "ig");
    }
}
exports.Profanity = Profanity;
exports.profanity = new Profanity();
exports.default = exports.profanity;
//# sourceMappingURL=profanity.js.map